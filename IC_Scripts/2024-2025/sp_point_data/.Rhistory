"LOCATIONTYPE", "Fluid", "Material", "Diam_in", "Length_ft", "MAXOPPRESSURE",
"line_age_yr", "CONSTRUCTDATE", "risk", "geometry")
flowlines <- flowlines %>% select(all_of(new_order))
# check
columns_to_check <- c("Status", "FLOWLINEACTION", "LOCATIONTYPE", "Fluid", "Material")
for (column in columns_to_check) {
if (column %in% colnames(flowlines)) {
vals <- unique(flowlines[[column]])
cat("Unique values in", column, ":", paste(vals, collapse = ", "), "\n")
} else {
cat(column, ": Column not found in DataFrame.\n")
}
}
# Mapping
status_mapping <- c(
"Active" = "Active", "ACTIVE" = "Active", "Actove" = "Active", "Avtive" = "Active",
"Actve" = "Active", "active" = "Active", "Actuve" = "Active", "Flowline" = "Active",
"Out of Service" = "Out of Service", "OOS" = "Out of Service", "OutofService" = "Out of Service",
"Out-of-Service" = "Out of Service", "Out Of Service" = "Out of Service",
"Out of service" = "Out of Service", "OUT OF SERVICE" = "Out of Service",
"OOSLAT" = "Out of Service",
"Abandoned" = "Abandoned", "abandoned" = "Abandoned", "Abandoned in Place" = "Abandoned",
"ABANDONED" = "Abandoned", "Abandon" = "Abandoned", "Abadnon" = "Abandoned",
"TA" = "Abandoned", "Abandonded" = "Abandoned", "Plugged" = "Abandoned", "AB" = "Abandoned",
"Inactive" = "Inactive", "InActive" = "Inactive", "INACTIVE" = "Inactive", "IDLE" = "Inactive",
"Pending Analysis" = "Pending Analysis", "PA" = "Pending Analysis",
"ABiP" = "Pending Analysis", "ABIP" = "Pending Analysis", "AIP" = "Pending Analysis",
"Shut In" = "Shut In", "shut in" = "Shut In", "Shut in" = "Shut In", "SI" = "Shut In",
"Pre-Abandonment" = "Pre-Abandonment", "Pre Abandonment" = "Pre-Abandonment",
"PreAbandonment" = "Pre-Abandonment", "Pre-Abandoned" = "Pre-Abandonment",
"Removed" = "Removed", "REMOVED" = "Removed", "REMOVED DUPLICATE" = "Removed",
"Partial Removed see comment" = "Removed",
"New Construction" = "New Construction",
"PreCommission" = "Pre-Commissioned", "Pre-commissioned" = "Pre-Commissioned",
"Pre-Commissioned" = "Pre-Commissioned",
"Flushed and capped" = "Decommissioned",
"Flow filled and capped" = "Decommissioned",
"Discontinued" = "Decommissioned",
"Injection" = "Injection", "Injecting" = "Injection",
"Future" = "Planned", "Planned" = "Planned",
"Nitrogen" = "DROP_ROW",
"Air Line" = "DROP_ROW",
"3rd Party Line" = "DROP_ROW",
"Turned into Air Line" = "DROP_ROW",
"Unknown" = NA, "Status" = NA, "unk" = NA, "0" = NA
)
flowlines <- flowlines %>%
mutate(Status = recode(Status, !!!status_mapping)) %>%
filter(Status != "DROP_ROW")
print(unique(flowlines$Status))
flowlineaction_mapping <- c(
"Out of Service" = "Out of Service",
"Removed From Service" = "Out of Service",
"Pre-Abandonment Notice" = "Pre-Abandonment Notice",
"Abandonment Verification" = "Abandonment",
"Realignment" = "Realignment",
"Registration" = "Registration",
"Abandonment" = "Abandonment"
)
flowlines <- flowlines %>%
mutate(FLOWLINEACTION = recode(FLOWLINEACTION, !!!flowlineaction_mapping))
print(unique(flowlines$FLOWLINEACTION))
locationtype_mapping <- c(
"Production Facilities" = "Production Facilities",
"Well Site" = "Well Site",
"Manifold" = "Manifold",
"Compressor Station" = "Compressor Station",
"Gathering Line" = "Gathering Line",
"Crude Oil Transfer Line" = "Crude Oil Transfer Line",
"Produced Water Transfer System" = "Produced Water Transfer System"
)
flowlines <- flowlines %>%
mutate(LOCATIONTYPE = recode(LOCATIONTYPE, !!!locationtype_mapping))
print(unique(flowlines$LOCATIONTYPE))
fluid_mapping <- c(
"Natual Gas" = "Natural Gas", "Natural Gas Production" = "Natural Gas",
"Natural Gas Lift" = "Natural Gas", "Natuarl Gas" = "Natural Gas",
"Natural Gas High Pressure" = "Natural Gas", "Natural Gas Supply" = "Natural Gas",
"Natural Gas Sales" = "Natural Gas", "Supply Gas" = "Natural Gas",
"Fuel Gas" = "Natural Gas",
"Oil" = "Crude Oil", "Crude Oil" = "Crude Oil",
"Crude Oil Unprocessed" = "Crude Oil",
"Crude Oil Emulsion" = "Crude Oil Emulsion",
"Crude Oil Emmulsion, Water And Oil" = "Crude Oil Emulsion",
"Crude Oill Emulsion" = "Crude Oil Emulsion",
"Crude Oil And Water Emulsion" = "Crude Oil Emulsion",
"Oil Water Emulsion" = "Crude Oil Emulsion",
"Oil/Water" = "Crude Oil Emulsion", "Oil Water" = "Crude Oil Emulsion",
"Oil And Water" = "Crude Oil Emulsion", "Emulsion" = "Crude Oil Emulsion",
"Crude Oil / Produced Water" = "Crude Oil Emulsion",
"Produced Water" = "Produced Water", "Water" = "Produced Water",
"Saltwater" = "Produced Water", "Injection Produced Water" = "Produced Water",
"Produced  Water" = "Produced Water", "Produced/Waste Water" = "Produced Water",
"Waste Water/Produced Water/Formation Water" = "Produced Water",
"Fresh Water" = "Produced Water", "(Other) Treated Produced Water" = "Produced Water",
"Co2" = "Co2/Produced Water", "C02/Prod Water" = "Co2/Produced Water",
"Co2/Prod Water" = "Co2/Produced Water", "Co2Produced Water" = "Co2/Produced Water",
"Co2/Produced Wtaer" = "Co2/Produced Water", "Co2 Produced Water" = "Co2/Produced Water",
"Co2/Produced" = "Co2/Produced Water",
"3 Phase" = "Multiphase", "Multiphase" = "Multiphase", "Multi-Phase" = "Multiphase",
"Mulitphase" = "Multiphase", "Multi Phase" = "Multiphase", "Mulit Phase" = "Multiphase",
"Mutliphase" = "Multiphase", "Oil, Water, Gas" = "Multiphase", "Oil-Gas-Water" = "Multiphase",
"Gas, Oil And Water" = "Full Well Stream", "Oil /Water/Gas" = "Full Well Stream",
"Oil/Gas/Water" = "Full Well Stream", "Oil, Gas, Water" = "Full Well Stream",
"Gas,  Oil And Water" = "Full Well Stream", "Natural Gas/Condensate/Produced Water" = "Full Well Stream",
"Condensate" = "Condensate",
"Poly" = "Polymer Fluids", "Polymer fluids" = "Polymer Fluids",
"Liquid" = "Other", "Liquids (Wtr/Cond)" = "Other",
"Unprocessed Production Fluids" = "Other", "Production Fluids" = "Other",
"Produced Fluids" = "Other", "Other" = "Other",
"Other (Natural Gas Liquid)" = "Other", "Other- Nitrogen/ Natural Gas" = "Other",
"Service Line" = "Other", "Air" = "Other", "Cox V2" = "Other",
"Steel" = "Other", "Fluid" = "Other", "Vent" = "Other",
"Unk" = NA, "Unknown" = NA
)
flowlines <- flowlines %>%
mutate(
Fluid = str_to_title(str_trim(Fluid)),
Fluid = recode(Fluid, !!!fluid_mapping)
)
print(sort(unique(na.omit(flowlines$Fluid))))
material_mapping <- c(
"Carbon Steel" = "Carbon Steel", "Carbonsteel" = "Carbon Steel", "Carbon  Steel" = "Carbon Steel",
"Carbon Steel Sch 80" = "Carbon Steel", "Carbon Steel - Hdpe" = "Carbon Steel/HDPE",
"Carbon Steel-Hdpe" = "Carbon Steel/HDPE", "Carbon Steel And Hdpe" = "Carbon Steel/HDPE",
"Carbon Steel/Hdpe" = "Carbon Steel/HDPE", "Carbon Steel/HDPE" = "Carbon Steel/HDPE",
"Hdpe/Steel" = "Carbon Steel/HDPE", "HDPE/Steel" = "Carbon Steel/HDPE",
"Hdpe Lined Steel" = "Carbon Steel/HDPE", "Hdpe/Steel, Flexsteel" = "Carbon Steel/HDPE/Flexsteel",
"Carbon Steel, Hdpe,Stainless Steel" = "Carbon Steel/HDPE/Stainless Steel",
"Carbon Steel, Hdpe, Stainless Steel" = "Carbon Steel/HDPE/Stainless Steel",
"Carbon Steel/Stainless Steel/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Carbon Steel/Hdpe/Stainless" = "Carbon Steel/HDPE/Stainless Steel",
"Carbon Steel/Hdpe/Stainless Steel" = "Carbon Steel/HDPE/Stainless Steel",
"Carbon Steel/Stainless/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Stainless/Carbon Steel/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Stainless/ Carbon Steel/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Stainless Steel/Carbon Steel/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Stainless/Carbonsteel/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Satinless/Carbon Steel/Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Stainless/Carbon Steel/Hspe" = "Carbon Steel/HDPE/Stainless Steel",
"Stainless/Carbon Steel/ Hdpe" = "Carbon Steel/HDPE/Stainless Steel",
"Carbon Steel/Fiberglass" = "Fiberglass/Carbon Steel",
"Carbon Steel Mixed With Fiberglass" = "Fiberglass/Carbon Steel",
"Fiberglass" = "Fiberglass", "Fibergalss" = "Fiberglass", "Fiberspar" = "Fiberglass",
"Fiber Glass" = "Fiberglass", "Flexspar" = "Fiberglass", "Fiberoptic" = "Fiberglass",
"Fiberglass & Fiberspar" = "Fiberglass", "Fiberglass And Carbon Steel" = "Fiberglass/Carbon Steel",
"Fiberglass Sleaved W/ Hdpe" = "Fiberglass/HDPE", "Fiberglass And Hdpe" = "Fiberglass/HDPE",
"Hdpe/Fiberglass" = "Fiberglass/HDPE",
"Steel" = "Steel", "Stainless" = "Steel", "Stainless Steel" = "Steel",
"Coated Steel" = "Steel", "Lined Steel" = "Steel", "Flexpipe" = "Steel",
"Flex Steel" = "Steel", "Flexsteel" = "Steel",
"Other (Flexsteel)" = "Steel", "Other (Flex Steel)" = "Steel", "Other (Flex Pipe)" = "Steel",
"Hdpe" = "HDPE", "Hdpe Poly" = "HDPE", "Hdpi Poly" = "HDPE",
"Hdpe Line Sdr 7" = "HDPE", "Hdpe Sdr7" = "HDPE", "Hdpe Sdr11" = "HDPE",
"Composite Hdpe" = "HDPE", "High-Density Polyethylene (Hdpe)" = "HDPE",
"Poly" = "Polycarbonate", "Polyline" = "Polycarbonate", "Polycarbonate" = "Polycarbonate",
"Other (Poly)" = "Polycarbonate", "Sdr 7 Poly" = "Polycarbonate",
"Poly & Steel" = "Polycarbonate/Steel", "Steel/Poly" = "Polycarbonate/Steel",
"Poly/Steel" = "Polycarbonate/Steel", "Polycarbonate/Steel" = "Polycarbonate/Steel",
"Poly Sleeved Steel" = "Polycarbonate/Steel", "Hdpe Poly Sdr 11" = "Polycarbonate/HDPE",
"Sdr7 Polyethelyne" = "Polyethylene", "Sdr 11 Poly Pipe" = "Polyethylene",
"Sdr 11 Poly" = "Polyethylene", "Poly Pipe" = "Polyethylene",
"Sdr_Poly" = "Polyethylene", "Sdr-11" = "Polyethylene", "Sdr-11 Poly" = "Polyethylene",
"Poly Sdr 7" = "Polypropylene", "Poly Sdr-7" = "Polypropylene",
"Pvc" = "PVC",
"Duplex" = "Duplex",
"Zaplock" = "Other",
"Plastic" = "Other", "Polypipe" = "Other", "Core Linepipe" = "Other", "Flex Pipe" = "Other",
"Shawcor Fp150" = "Other", "Zapock" = "Other", "Other (Hdpe And Tubing)" = "Other",
"Other (Please Specify)" = "Other", "Other (Stainless Steel)" = "Other",
"Fplp" = "Other", "Oil" = "Other", "Gas" = "Other", "Co2/Produced Water" = "Other",
"Other" = "Other",
"Unknown" = NA, "Other (Unknown)" = NA, "Unk" = NA, "0" = NA,
"Material" = NA, "Sdr" = NA, "Flowline" = NA
)
flowlines <- flowlines %>%
mutate(
Material = str_to_title(str_trim(Material)),
Material = recode(Material, !!!material_mapping)
)
print(unique(flowlines$Material))
# rename columns
flowlines <- flowlines %>%
rename(
unique_id = unique_id,
operator_name = Operator,
operator_number = OPERATOR_NUM,
flowline_id = FLOWLINEID,
location_id = LOCATION_ID,
status = Status,
flowline_action = FLOWLINEACTION,
location_type = LOCATIONTYPE,
fluid = Fluid,
material = Material,
diameter_in = Diam_in,
length_ft = Length_ft,
max_operating_pressure = MAXOPPRESSURE,
line_age_yr = line_age_yr,
construct_date = CONSTRUCTDATE,
geometry = geometry
)
#------SPILLS-------
spills <- st_read("spills.geojson")
colnames(spills)
# Operator name cleanup
if ("Operator" %in% colnames(spills)) {
spills$Operator <- dplyr::recode(spills$Operator, !!!op_name_fix)
}
# drop columns
columns_to_remove <- c(
"trkg_num", "facility_type", "Spill_Desc", "Spill.Type", "Root.Cause",
"Preventative.Measure", "Detailed.Root.Cause.Type", "facility_status", "Gathering.", "Metallic.")
cols_to_drop <- intersect(columns_to_remove, colnames(spills))
cat("Dropping these existing columns:", paste(cols_to_drop, collapse = ", "), "\n")
spills <- spills %>% select(-all_of(cols_to_drop))
# add risk column
spills$risk <- 1
# new order
new_order <- c(
"Operator.Name", "Root.Cause.Type", "incident_date", "risk", "Long", "Lat", "geometry")
spills <- spills %>% select(all_of(new_order))
# rename columns
spills <- spills %>%
rename(
operator_name = Operator.Name,
root_cause = Root.Cause.Type,
lon = Long,
lat = Lat
)
# check:
root_cause_mapping <- c(
"Equipment failure" = "Equipment Failure"
)
spills <- spills %>%
mutate(root_cause = recode(root_cause, !!!root_cause_mapping))
print(unique(spills$root_cause))
# missing geometry
empties <- st_is_empty(spills)
if (!any(empties)) stop("No empty geometries to fill.")
df <- st_drop_geometry(spills[empties, ])
df$lon <- suppressWarnings(as.numeric(df$lon))
df$lat <- suppressWarnings(as.numeric(df$lat))
swap <- which((abs(df$lat) > 90 & abs(df$lon) <= 180) |
(abs(df$lon) > 180 & abs(df$lat) <= 90))
if (length(swap)) {
tmp <- df$lon[swap]; df$lon[swap] <- df$lat[swap]; df$lat[swap] <- tmp
}
ok <- is.finite(df$lon) & is.finite(df$lat) &
df$lon >= -180 & df$lon <= 180 &
df$lat >=  -90 & df$lat <=  90
df <- df[ok, , drop = FALSE]
fill_idx <- which(empties)[ok]
pts <- st_as_sf(df, coords = c("lon","lat"), crs = 4326, remove = FALSE)
pts <- st_transform(pts, st_crs(spills))
st_geometry(spills)[fill_idx] <- st_geometry(pts)
sum(st_is_empty(spills))
# drop NA's None's 0's
spills <- na.omit(spills)
# Save as GeoJSON
st_write(spills, "clean_spills.geojson", driver = "GeoJSON", delete_dsn = TRUE)
st_write(flowlines, "clean_combined_flowlines.geojson", driver = "GeoJSON", delete_dsn = TRUE)
cat("# flowlines rows:", nrow(flowlines), "\n")
cat("# spills rows:", nrow(spills), "\n")
# --- run this right after you finish imputing into `df` ---
# assumes you saved pre-impute copy as `df_pre` and have `num_targets`
library(dplyr)
library(purrr)
library(tidyr)
library(ggplot2)
# 1) identify which entries were imputed
imp_mask <- setNames(lapply(num_targets, function(c) is.na(df_pre[[c]])), num_targets)
# --- deps ---
library(sf)
library(dplyr)
library(stringr)
library(tidyr)
library(FNN)
library(purrr)
library(ggplot2)
setwd("~/Desktop/MINES/COGCC-Risk-Analysis/Data")
# --- load & normalize operator names ---
flowlines <- st_read("clean_combined_flowlines.geojson") %>%
mutate(operator_name = str_trim(str_to_upper(operator_name)))
spills <- st_read("clean_spills.geojson") %>%
mutate(operator_name = str_trim(str_to_upper(operator_name)))
# --- match by operator ---
common_ops <- intersect(unique(flowlines$operator_name), unique(spills$operator_name))
flowlines_matched <- filter(flowlines, operator_name %in% common_ops)
cat("Matched flowlines:", nrow(flowlines_matched), "\n")
# --- helpers ---
scale_with <- function(M, center, scale) sweep(sweep(M, 2, center, `-`), 2, scale, `/`)
knn_impute_col <- function(df_num, target, k = 5, backup = c("median","mean"), ignore_zero_neighbors = TRUE) {
backup <- match.arg(backup)
feats <- setdiff(colnames(df_num), target)
feat_complete <- complete.cases(df_num[, feats, drop = FALSE])
obs <- which(!is.na(df_num[[target]]) & feat_complete)
mis <- which( is.na(df_num[[target]]) & feat_complete)
if (!length(mis) || !length(obs)) {
if (anyNA(df_num[[target]])) {
fill <- if (backup == "median") median(df_num[[target]], na.rm = TRUE) else mean(df_num[[target]], na.rm = TRUE)
df_num[[target]][is.na(df_num[[target]])] <- fill
}
return(df_num[[target]])
}
X_obs <- as.matrix(df_num[obs, feats, drop = FALSE])
X_mis <- as.matrix(df_num[mis, feats, drop = FALSE])
ctr <- colMeans(X_obs)
sds <- apply(X_obs, 2, sd); sds[!is.finite(sds) | sds == 0] <- 1
X_obs_s <- scale_with(X_obs, ctr, sds)
X_mis_s <- scale_with(X_mis, ctr, sds)
k_use <- min(k, nrow(X_obs_s))
nn <- FNN::get.knnx(data = X_obs_s, query = X_mis_s, k = k_use)$nn.index
y_obs <- df_num[[target]][obs]
y_nonzero <- y_obs[y_obs != 0]
fallback <- if (ignore_zero_neighbors && length(y_nonzero)) median(y_nonzero, na.rm = TRUE) else median(y_obs, na.rm = TRUE)
imputed_vals <- apply(nn, 1, function(idx) {
vals <- y_obs[idx]
if (ignore_zero_neighbors) vals <- vals[vals != 0]
if (!length(vals) || all(!is.finite(vals))) return(fallback)
mean(vals, na.rm = TRUE)
})
out <- df_num[[target]]
out[mis] <- imputed_vals
out[is.na(out)] <- fallback
out
}
# --- select cols, encode cats, copy pre-impute, zero->NA ---
cols_for_impute <- intersect(
c("max_operating_pressure","diameter_in","length_ft","line_age_yr","material","fluid"),
names(flowlines_matched)
)
zero_as_na <- intersect(c("max_operating_pressure","diameter_in","length_ft"), cols_for_impute)
df <- flowlines_matched[, cols_for_impute, drop = FALSE]
if ("material" %in% names(df)) df$material_encoded <- as.integer(factor(replace_na(df$material, "")))
if ("fluid"    %in% names(df)) df$fluid_encoded    <- as.integer(factor(replace_na(df$fluid, "")))
df <- df %>% select(-any_of(c("material","fluid"))) %>% st_drop_geometry()
df[] <- lapply(df, function(x) {
if (is.factor(x)) as.integer(x)
else if (is.logical(x)) as.integer(x)
else suppressWarnings(as.numeric(x))
})
for (zcol in zero_as_na) df[[zcol]][df[[zcol]] == 0] <- NA_real_
num_targets <- intersect(c("max_operating_pressure","diameter_in","length_ft","line_age_yr"), names(df))
df_pre <- df
# --- impute ---
before_counts <- tibble(
column = num_targets,
na_before   = sapply(df[num_targets], \(x) sum(is.na(x))),
zero_before = sapply(df[num_targets], \(x) sum(x == 0, na.rm = TRUE))
)
for (tg in num_targets) df[[tg]] <- knn_impute_col(df, target = tg, k = 5, backup = "median", ignore_zero_neighbors = TRUE)
after_counts <- tibble(
column = num_targets,
na_after   = sapply(df[num_targets], \(x) sum(is.na(x))),
zero_after = sapply(df[num_targets], \(x) sum(x == 0, na.rm = TRUE))
)
print(left_join(before_counts, after_counts, by = "column"))
# --- sanity checks: compare distributions, flag extremes, (optional) winsorize ---
imp_mask <- setNames(lapply(num_targets, function(c) is.na(df_pre[[c]])), num_targets)
compare_tbl <- map_dfr(num_targets, function(c) {
x   <- df[[c]]; imp <- imp_mask[[c]]
obs <- x[!imp]; impv <- x[imp]
ks_p <- suppressWarnings(if (length(obs)>1 && length(impv)>1) ks.test(obs, impv)$p.value else NA_real_)
tibble(
column=c, n_obs=sum(!imp), n_imp=sum(imp),
mean_obs=mean(obs,na.rm=TRUE), mean_imp=mean(impv,na.rm=TRUE),
sd_obs=sd(obs,na.rm=TRUE), sd_imp=sd(impv,na.rm=TRUE),
p5_obs=quantile(obs,0.05,na.rm=TRUE), p95_obs=quantile(obs,0.95,na.rm=TRUE),
p5_imp=quantile(impv,0.05,na.rm=TRUE), p95_imp=quantile(impv,0.95,na.rm=TRUE),
ks_p=ks_p
)
})
print(compare_tbl)
flag_list <- map(num_targets, function(c) {
x <- df[[c]]; imp <- imp_mask[[c]]; obs <- x[!imp]
lo <- quantile(obs,0.01,na.rm=TRUE); hi <- quantile(obs,0.99,na.rm=TRUE)
mu <- mean(obs,na.rm=TRUE); sg <- sd(obs,na.rm=TRUE); if (!is.finite(sg)||sg==0) sg <- NA_real_
idx <- which(imp); val <- x[idx]
out_of_band <- val < lo | val > hi
z_bad <- if (is.na(sg)) rep(FALSE,length(val)) else abs((val-mu)/sg) > 3
tibble(column=c, row_idx=idx, value=val, out_of_band, z_bad)
})
flags <- bind_rows(flag_list) %>% filter(out_of_band | z_bad)
cat("Imputed values flagged as extreme:", nrow(flags), "\n")
print(head(flags, 20))
# OPTIONAL: winsorize imputed to observed [p1,p99]. Comment this block out if not desired.
winsorize_to_obs <- function(dat, mask, obs_vals, p_lo=0.01, p_hi=0.99) {
lo <- quantile(obs_vals, p_lo, na.rm=TRUE)
hi <- quantile(obs_vals, p_hi, na.rm=TRUE)
dat[mask] <- pmin(pmax(dat[mask], lo), hi)
dat
}
for (c in num_targets) {
imp <- imp_mask[[c]]
if (!any(imp)) next
df[[c]] <- winsorize_to_obs(df[[c]], imp, df[[c]][!imp])
}
# quick density overlays (comment out if you don’t want plots)
for (c in num_targets) {
x <- df[[c]]; imp <- imp_mask[[c]]
plt <- data.frame(val=x, grp=ifelse(imp,"imputed","observed"))
print(ggplot(plt, aes(val, ..density.., linetype=grp)) + geom_density() + labs(title=c, x=c, y="density"))
}
# --- write back & save ---
flowlines_matched[num_targets] <- df[, num_targets, drop = FALSE]
keep_idx <- complete.cases(st_drop_geometry(flowlines_matched))
cat("Rows with any remaining NA (non-geometry):", sum(!keep_idx), "\n")
flowlines_matched <- flowlines_matched[keep_idx, , drop = FALSE]
# --- deps ---
library(sf)
library(dplyr)
library(stringr)
library(tidyr)
library(FNN)
library(purrr)
setwd("~/Desktop/MINES/COGCC-Risk-Analysis/Data")
# --- load & normalize operator names ---
flowlines <- st_read("clean_combined_flowlines.geojson") %>%
mutate(operator_name = str_trim(str_to_upper(operator_name)))
spills <- st_read("clean_spills.geojson") %>%
mutate(operator_name = str_trim(str_to_upper(operator_name)))
# --- split matched / unmatched by operator_name ---
common_ops <- intersect(unique(flowlines$operator_name), unique(spills$operator_name))
flowlines_matched   <- filter(flowlines, operator_name %in% common_ops)
flowlines_unmatched <- filter(flowlines, !operator_name %in% common_ops)
# --- unmatched: drop rows with any NA (excluding geometry) ---
keep_unmatched <- complete.cases(st_drop_geometry(flowlines_unmatched))
flowlines_unmatched_clean <- flowlines_unmatched[keep_unmatched, , drop = FALSE]
# --- helpers (kNN impute for single column) ---
scale_with <- function(M, center, scale) sweep(sweep(M, 2, center, `-`), 2, scale, `/`)
knn_impute_col <- function(df_num, target, k = 5, backup = c("median","mean"), ignore_zero_neighbors = TRUE) {
backup <- match.arg(backup)
feats <- setdiff(colnames(df_num), target)
feat_complete <- complete.cases(df_num[, feats, drop = FALSE])
obs <- which(!is.na(df_num[[target]]) & feat_complete)
mis <- which( is.na(df_num[[target]]) & feat_complete)
if (!length(mis) || !length(obs)) {
if (anyNA(df_num[[target]])) {
fill <- if (backup == "median") median(df_num[[target]], na.rm = TRUE) else mean(df_num[[target]], na.rm = TRUE)
df_num[[target]][is.na(df_num[[target]])] <- fill
}
return(df_num[[target]])
}
X_obs <- as.matrix(df_num[obs, feats, drop = FALSE])
X_mis <- as.matrix(df_num[mis, feats, drop = FALSE])
ctr <- colMeans(X_obs)
sds <- apply(X_obs, 2, sd); sds[!is.finite(sds) | sds == 0] <- 1
X_obs_s <- scale_with(X_obs, ctr, sds)
X_mis_s <- scale_with(X_mis, ctr, sds)
k_use <- min(k, nrow(X_obs_s))
nn <- FNN::get.knnx(data = X_obs_s, query = X_mis_s, k = k_use)$nn.index
y_obs <- df_num[[target]][obs]
y_nonzero <- y_obs[y_obs != 0]
fallback <- if (ignore_zero_neighbors && length(y_nonzero)) median(y_nonzero, na.rm = TRUE) else median(y_obs, na.rm = TRUE)
imputed_vals <- apply(nn, 1, function(idx) {
vals <- y_obs[idx]
if (ignore_zero_neighbors) vals <- vals[vals != 0]
if (!length(vals) || all(!is.finite(vals))) return(fallback)
mean(vals, na.rm = TRUE)
})
out <- df_num[[target]]
out[mis] <- imputed_vals
out[is.na(out)] <- fallback
out
}
# --- matched: prepare frame, encode cats, zero->NA, impute selected numerics ---
cols_for_impute <- intersect(c("max_operating_pressure","diameter_in","length_ft","line_age_yr","material","fluid"),
names(flowlines_matched))
zero_as_na <- intersect(c("max_operating_pressure","diameter_in","length_ft"), cols_for_impute)
num_targets <- intersect(c("max_operating_pressure","diameter_in","length_ft","line_age_yr"), cols_for_impute)
df <- flowlines_matched[, cols_for_impute, drop = FALSE]
if ("material" %in% names(df)) df$material_encoded <- as.integer(factor(replace_na(df$material, "")))
if ("fluid"    %in% names(df)) df$fluid_encoded    <- as.integer(factor(replace_na(df$fluid, "")))
df <- df %>% select(-any_of(c("material","fluid"))) %>% st_drop_geometry()
df[] <- lapply(df, function(x) { if (is.factor(x)) as.integer(x) else suppressWarnings(as.numeric(x)) })
for (zcol in zero_as_na) df[[zcol]][df[[zcol]] == 0] <- NA_real_
df_pre <- df
for (tg in num_targets) df[[tg]] <- knn_impute_col(df, target = tg, k = 5, backup = "median", ignore_zero_neighbors = TRUE)
# --- drop rows with imputed values far from observed ([p1,p99] or |z|>3 per column) ---
imp_mask <- setNames(lapply(num_targets, function(c) is.na(df_pre[[c]])), num_targets)
flag_list <- map(num_targets, function(c) {
x <- df[[c]]; imp <- imp_mask[[c]]; obs <- x[!imp]
if (!length(obs)) return(tibble(column=c, row_idx=integer(), value=numeric(), out_of_band=logical(), z_bad=logical()))
lo <- quantile(obs, 0.01, na.rm=TRUE); hi <- quantile(obs, 0.99, na.rm=TRUE)
mu <- mean(obs, na.rm=TRUE); sg <- sd(obs, na.rm=TRUE); if (!is.finite(sg)||sg==0) sg <- NA_real_
idx <- which(imp); if (!length(idx)) return(tibble(column=c, row_idx=integer(), value=numeric(), out_of_band=logical(), z_bad=logical()))
val <- x[idx]
out_of_band <- val < lo | val > hi
z_bad <- if (is.na(sg)) rep(FALSE, length(val)) else abs((val - mu)/sg) > 3
tibble(column=c, row_idx=idx, value=val, out_of_band, z_bad)
})
flags <- bind_rows(flag_list) %>% filter(out_of_band | z_bad)
rows_to_drop <- unique(flags$row_idx)
if (length(rows_to_drop)) {
df <- df[-rows_to_drop, , drop = FALSE]
flowlines_matched <- flowlines_matched[-rows_to_drop, , drop = FALSE]
}
# --- write back imputed numerics, drop any remaining NA rows, then combine ---
flowlines_matched[num_targets] <- df[, num_targets, drop = FALSE]
keep_matched <- complete.cases(st_drop_geometry(flowlines_matched))
flowlines_matched_clean <- flowlines_matched[keep_matched, , drop = FALSE]
combined_flowlines <- bind_rows(flowlines_unmatched_clean, flowlines_matched_clean)
# optional saves:
# st_write(flowlines_matched_clean, "flowlines_matched_imputed_clean.geojson", delete_dsn = TRUE)
# st_write(combined_flowlines, "flowlines_combined_clean.geojson", delete_dsn = TRUE)
# quick counts
cat("Unmatched kept:", nrow(flowlines_unmatched_clean), "\n")
cat("Matched kept:", nrow(flowlines_matched_clean), "\n")
cat("Combined total:", nrow(combined_flowlines), "\n")
View(combined_flowlines)
# optional saves:
st_write(combined_flowlines, "interpolated_clean_flowlines.geojson", delete_dsn = TRUE)
