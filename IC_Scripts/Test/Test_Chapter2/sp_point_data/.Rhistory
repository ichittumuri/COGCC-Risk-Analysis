y_pred <- as.integer(y_prob >= 0.5)
loglik_i <- y_true * log(pmax(pmin(y_prob, 1 - 1e-15), 1e-15)) +
(1 - y_true) * log(pmax(pmin(1 - y_prob, 1 - 1e-15), 1e-15))
loglik   <- sum(loglik_i)
rmse     <- sqrt(mean((y_prob - y_true)^2))
tp <- sum(y_pred == 1 & y_true == 1)
tn <- sum(y_pred == 0 & y_true == 0)
fp <- sum(y_pred == 1 & y_true == 0)
fn <- sum(y_pred == 0 & y_true == 1)
accuracy  <- (tp + tn) / length(y_true)
precision <- ifelse((tp + fp) > 0, tp / (tp + fp), NA_real_)
recall    <- ifelse((tp + fn) > 0, tp / (tp + fn), NA_real_)
f1        <- ifelse((precision + recall) > 0,
2 * precision * recall / (precision + recall),
NA_real_)
# --- Add these: sensitivity, specificity, balanced accuracy, MCC -------------
sensitivity <- ifelse((tp + fn) > 0, tp / (tp + fn), NA_real_)  # recall for positives
specificity <- ifelse((tn + fp) > 0, tn / (tn + fp), NA_real_)  # recall for negatives
balanced_accuracy <- mean(c(sensitivity, specificity), na.rm = TRUE)
balanced_accuracy
mcc <- ifelse(
(tp + fp) > 0 & (tp + fn) > 0 & (tn + fp) > 0 & (tn + fn) > 0,
(tp * tn - fp * fn) / sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn)),
NA_real_
)
spatial_Z_metrics <- tibble::tibble(
model           = "SpatialOnly",
set             = "TEST",
n               = length(y_true),
log_likelihood  = loglik,
rmse            = rmse,
accuracy        = accuracy,
precision       = precision,
recall          = recall,
f1              = f1,
sensitivity     = sensitivity,
specificity     = specificity,
balanced_accuracy = balanced_accuracy,
mcc             = mcc,
threshold       = 0.5
)
readr::write_csv(spatial_Z_metrics, "metrics_spatial_plus_z.csv")
=============================================================================
# =============================================================================
# Compare GLM, Spatial-only, Spatial+Z
# =============================================================================
library(dplyr)
library(readr)
library(ggplot2)
library(scales)
library(tidyr)
library(stringr)
setwd("~/Desktop/MINES/COGCC-Risk-Analysis/Data")
# ---- 1) Load standardized predictions ---------------------------------------
pred_glm  <- read_csv("predictions_glm.csv", show_col_types = FALSE)
pred_so   <- read_csv("predictions_spatial_only.csv", show_col_types = FALSE)
pred_sz   <- read_csv("predictions_spatial_plus_z.csv", show_col_types = FALSE)
df_all <- bind_rows(pred_glm, pred_so, pred_sz) %>%
mutate(
model = factor(model, levels = c("GLM", "SpatialOnly", "SpatialPlusZ"))
)
# Optional: save the combined dataset for downstream use
write_csv(df_all, "predictions_all_models.csv")
# ---- 2) Load metrics and combine --------------------------------------------
met_glm <- read_csv("metrics_glm.csv", show_col_types = FALSE)
met_so  <- read_csv("metrics_spatial_only.csv", show_col_types = FALSE)
met_sz  <- read_csv("metrics_spatial_plus_z.csv", show_col_types = FALSE)
metrics_all <- bind_rows(met_glm, met_so, met_sz) %>%
mutate(
model = factor(model, levels = c("GLM", "SpatialOnly", "SpatialPlusZ"))
) %>%
arrange(model)
write_csv(metrics_all, "metrics_all_models.csv")
print(metrics_all)
# ---- 5) Metrics bar chart (optional) ----------------------------------------
metrics_table <- metrics_all %>%
select(model, accuracy, precision, recall, f1) %>%
arrange(model)
print(metrics_table)
# ---- Pull balanced accuracy from metrics_all ------------------------------
bal_acc <- metrics_all %>%
select(model, balanced_accuracy) %>%
mutate(
balanced_accuracy = round(balanced_accuracy, 3)  # round for display
)
# Build custom labels with balanced accuracy appended
# ---- Model labels without balanced accuracy ------------------------------
model_labels <- setNames(
c("Covariates Only", "Spatial Only", "Spatial + Covariates"),
levels(metrics_all$model)
)
# ---- Predicted risk maps --------------------------------------------------
df_map <- df_all %>%
dplyr::group_by(model) %>%
dplyr::arrange(pred, .by_group = TRUE) %>%
dplyr::ungroup()
p_maps <- ggplot(df_map, aes(x = lon, y = lat)) +
geom_point(aes(color = pred), size = 2) +
scale_color_viridis_c(
option = "turbo",
name   = "Probability",
limits = c(0, 1),
breaks = seq(0, 1, 0.25),
oob    = scales::squish,
begin  = 0.12,
end    = 0.9
) +
coord_fixed() +
theme_minimal() +
labs(
title = "Predicted Spill Probability",
x = "Longitude",
y = "Latitude"
) +
facet_wrap(~ model, ncol = 3, labeller = as_labeller(model_labels)) +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.7)  # add box
)
p_maps
# ---- Observed risk map with border -----------------------------------------
p_obs <- ggplot(df_all %>% arrange(risk), aes(x = lon, y = lat)) +
geom_point(aes(color = as.numeric(risk)), size = 1.7, alpha = 0.8) +
scale_color_viridis_c(
option = "turbo",
name   = "Probability",
limits = c(0, 1),
breaks = seq(0, 1, 0.25),
oob    = scales::squish,
begin  = 0.12,
end    = 0.9
) +
coord_fixed() +
theme_minimal() +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1)  # add border
) +
labs(
# title = "Observed Spill Outcomes on Test Data",
x = "Longitude",
y = "Latitude"
)
p_obs
# Round nicely
metrics_table <- metrics_all %>%
select(model, accuracy, precision, recall, f1) %>%
arrange(model) %>%
mutate(
across(c(accuracy, precision, recall, f1), ~ round(.x, 3))
)
print(metrics_table)
library(dplyr)
library(ggplot2)
library(patchwork)
# 1) Reset theme
theme_set(theme_grey())
# 2) Helper: clean subtitles
mk_sub <- function(df) {
n <- nrow(df); s <- sum(df$risk == 1, na.rm = TRUE); p <- s / n
sprintf("n=%d | spills=%d | p(Spill)=%.3f", n, s, p)
}
sub_train <- mk_sub(train_data)
sub_test  <- mk_sub(test_data)
# 3) Common map with transparency, using same Turbo palette (no outlines)
common_map <- function(df, ttl, subttl) {
ggplot(df %>% arrange(risk), aes(lon, lat)) +
geom_point(
aes(color = as.numeric(risk)),
shape = 16,   # solid circle, no outline
size = 2,
alpha = 0.8
) +
scale_color_viridis_c(
option = "turbo",
name   = "Observed Outcome",
limits = c(0, 1),
breaks = c(0, 1),
labels = c("No Spill", "Spill"),
oob    = scales::squish,
begin  = 0.12,
end    = 0.9
) +
coord_fixed() +
theme_minimal() +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
) +
labs(
title    = ttl,
subtitle = subttl,
x = "Longitude", y = "Latitude"
)
}
p_train <- common_map(train_data, "Observed — Train", sub_train)
p_test  <- common_map(test_data,  "Observed — Test",  sub_test)
# 4) Combine
combined <- (p_train | p_test) +
plot_layout(guides = "collect") &
theme(
legend.position = "right",
plot.title = element_text(face = "bold"),
plot.subtitle = element_text()
)
combined
# ---- Predicted maps (3 facets side by side) ----
ggsave(
filename = "predicted_maps.png",
plot = p_maps,
width = 9, height = 3, dpi = 300
)
# ---- Observed map (single panel) ----
ggsave(
filename = "observed_map.png",
plot = p_obs,
width = 4.5, height = 4, dpi = 300
)
# ---- Combined train/test observed (2 panels) ----
ggsave(
filename = "observed_train_test.png",
plot = combined,
width = 8, height = 4, dpi = 300
)
library( fields)
epsilon <- .5
s0<- rbind( c(0,0),
c(0,-epsilon),
c(-epsilon,0),
c(epsilon,0),
c( 0,epsilon)
)
contrast<- cbind(c( 1,-.25,-.25,-.25,-.25))
# important that contrast zeroes out a linear surface.
cardinalX<- rbind(c(0,0),
c(1,0),
c(0,1)
)
M<- 100
delta<- seq( 0,3,length.out=M)
covTps<- rep( NA, M)
vars1<- rep( NA, M)
covTpsCenter<- rep( NA, M)
tmp<- Tps.cov(s0,s0, cardinalX= cardinalX)
vars0 <- c(t(contrast)%*%tmp%*%contrast)
for(k in 1:M ){
s1<- s0 + delta[k]
tmp<- Tps.cov(s0,s1, cardinalX= cardinalX)
covTpsCenter[k]<- tmp[1,1] # raw covariance of two center points
covTps[k] <- t(contrast)%*%tmp%*%contrast
tmp<- Tps.cov(s1,s1, cardinalX= cardinalX)
vars1[k] <- t(contrast)%*%tmp%*%contrast
}
plot( delta, covTps/sqrt( vars0*vars1), type="l",
xlab="distance separation", ylab="correlation contrasts")
# variance is constant
stats( vars1)
# here is the plot for just correlation among the center points
S0<- rbind( c(0,0))
S1<- matrix(s0, byrow=TRUE, nrow=M, ncol=2) +delta
COV01<- Tps.cov(S0,S1, cardinalX= cardinalX)
VAR0<- c(Tps.cov(S0,S0, cardinalX= cardinalX))
VAR1<-  diag( Tps.cov(S1,S1, cardinalX= cardinalX))
# funny variation due to interaction of delta spacing with
# cardinal points.
plot( delta, VAR1)
title("weird - not stationary")
plot( delta, COV01/ sqrt( VAR1*VAR0), type="l")
title( "correlations")
library( fields)
epsilon <- .5
s0<- rbind( c(0,0),
c(0,-epsilon),
c(-epsilon,0),
c(epsilon,0),
c( 0,epsilon)
)
contrast<- cbind(c( 1,-.25,-.25,-.25,-.25))
# important that contrast zeroes out a linear surface.
cardinalX<- rbind(c(0,0),
c(1,0),
c(0,1)
)
M<- 100
delta<- seq( 0,3,length.out=M)
covTps<- rep( NA, M)
vars1<- rep( NA, M)
covTpsCenter<- rep( NA, M)
tmp<- Tps.cov(s0,s0, cardinalX= cardinalX)
vars0 <- c(t(contrast)%*%tmp%*%contrast)
for(k in 1:M ){
s1<- s0 + delta[k]
tmp<- Tps.cov(s0,s1, cardinalX= cardinalX)
covTpsCenter[k]<- tmp[1,1] # raw covariance of two center points
covTps[k] <- t(contrast)%*%tmp%*%contrast
tmp<- Tps.cov(s1,s1, cardinalX= cardinalX)
vars1[k] <- t(contrast)%*%tmp%*%contrast
}
plot( delta, covTps/sqrt( vars0*vars1), type="l",
xlab="distance separation", ylab="correlation contrasts")
# variance is constant
stats( vars1)
# here is the plot for just correlation among the center points
S0<- rbind( c(0,0))
S1<- matrix(s0, byrow=TRUE, nrow=M, ncol=2) +delta
COV01<- Tps.cov(S0,S1, cardinalX= cardinalX)
VAR0<- c(Tps.cov(S0,S0, cardinalX= cardinalX))
VAR1<-  diag( Tps.cov(S1,S1, cardinalX= cardinalX))
# funny variation due to interaction of delta spacing with
# cardinal points.
plot( delta, VAR1)
title("weird - not stationary")
plot( delta, COV01/ sqrt( VAR1*VAR0), type="l")
title( "correlations")
View(cardinalX)
library( fields)
epsilon <- .5
s0<- rbind( c(0,0),
c(0,-epsilon),
c(-epsilon,0),
c(epsilon,0),
c( 0,epsilon)
)
# Think of s0 as a center point with its four cardinal neighbors at distance ε.
contrast<- cbind(c( 1,-.25,-.25,-.25,-.25))
# important that contrast zeroes out a linear surface.
#
# A 5-point **contrast** on the cross of locations in s0.
# Order in s0 is: center, south, west, east, north.
# Weights: +1 on the center, −1/4 on each of the 4 neighbors.
# This computes:   center − mean(neighbors)
#
# Why these weights?
# • They **sum to zero**:        1 + 4*(−1/4) = 0  → removes any constant level.
# • They give **zero first moments** in x and y:
#     sum(w_i * x_i) = 0,  sum(w_i * y_i) = 0     → removes any linear tilt (a + bx + cy).
#   So for any plane f(x,y)=a+bx+cy, this contrast evaluates to 0
#   (the center equals the average of its four symmetric neighbors).
#
# What does it measure then?
# • Only the local **curvature/bumps** (the part TPS actually models/penalizes).
# • It’s the 2-D analog of a **second difference** (discrete Laplacian stencil).
#
# Why is that important for TPS/IRF-2?
# • TPS is only defined up to a plane; raw variances depend on where you pin that plane.
# • Using a plane-killing contrast gives **stationary increments**:
#   the contrast’s variance is (effectively) constant across locations and
#   its correlation depends mainly on distance.
#
# Make a weight vector that does: center − average(neighbors).
# This cancels any flat/tilted plane so it only measures curvature.
cardinalX<- rbind(c(0,0),
c(1,0),
c(0,1)
)
# Think of a thin-plate spline (TPS) surface like a flexible sheet with little bumps on it.
# You can lift the whole sheet up/down (change its level).
# You can tilt it like a tray (change its overall slope).
# Those moves don’t change the bumps. TPS only “cares” about the bumps.
# Because of that, the math can’t decide the sheet’s exact level/tilt unless we pin it down.
#
# This picks three pin locations. A plane (level + tilt) is determined by three points, so:
# 1st point fixes the height reference.
# 2nd point fixes tilt left–right.
# 3rd point fixes tilt up–down.
#
# Pick 3 anchor points to "pin" the plane (level & tilt),
# so TPS covariances are well-defined.
M<- 100
delta<- seq( 0,3,length.out=M)
#shift cross by delta, 100 different times of magnitude between 0-3
covTps<- rep( NA, M)
vars1<- rep( NA, M)
covTpsCenter<- rep( NA, M)
# create empty vectors of M size
tmp<- Tps.cov(s0,s0, cardinalX= cardinalX)
# Get the covariance between every pair of the 5 points in s0 (TPS model)
vars0 <- c(t(contrast)%*%tmp%*%contrast)
# Var of a weighted sum = weights × covariance table × weights.
for(k in 1:M ){
# Try the k-th distance between our two plus-shaped stamps.
s1<- s0 + delta[k]
# Make a second copy of the plus-shape and slide it diagonally by delta[k].
# (Every point moves by (delta[k], delta[k]).)
tmp<- Tps.cov(s0,s1, cardinalX= cardinalX)
# Ask the “blanket model” how the readings from HOME (s0) and MOVED (s1)
# tend to wiggle together (a 5x5 cross-covariance matrix).
covTpsCenter[k]<- tmp[1,1] # raw covariance of two center points
# Pick out the togetherness of the two CENTER dots:
# home center vs moved center.
covTps[k] <- t(contrast)%*%tmp%*%contrast
# Now measure togetherness of the “squish test” (center - average of arms)
# at home vs the same squish test at the moved cross.
tmp<- Tps.cov(s1,s1, cardinalX= cardinalX)
# Ask how the MOVED cross’s own readings wiggle with themselves
# (a 5x5 covariance/variance matrix for s1).
vars1[k] <- t(contrast)%*%tmp%*%contrast
# How wiggly the MOVED “squish test” is by itself — its variance.
}
plot( delta, covTps/sqrt( vars0*vars1), type="l",
xlab="distance separation", ylab="correlation contrasts")
# variance is constant
stats( vars1)
library( fields)
epsilon <- .5
s0<- rbind( c(0,0),
c(0,-epsilon),
c(-epsilon,0),
c(epsilon,0),
c( 0,epsilon)
)
# Think of s0 as a center point with its four cardinal neighbors at distance ε.
contrast<- cbind(c( 1,-.25,-.25,-.25,-.25))
# important that contrast zeroes out a linear surface.
#
# A 5-point **contrast** on the cross of locations in s0.
# Order in s0 is: center, south, west, east, north.
# Weights: +1 on the center, −1/4 on each of the 4 neighbors.
# This computes:   center − mean(neighbors)
#
# Why these weights?
# • They **sum to zero**:        1 + 4*(−1/4) = 0  → removes any constant level.
# • They give **zero first moments** in x and y:
#     sum(w_i * x_i) = 0,  sum(w_i * y_i) = 0     → removes any linear tilt (a + bx + cy).
#   So for any plane f(x,y)=a+bx+cy, this contrast evaluates to 0
#   (the center equals the average of its four symmetric neighbors).
#
# What does it measure then?
# • Only the local **curvature/bumps** (the part TPS actually models/penalizes).
# • It’s the 2-D analog of a **second difference** (discrete Laplacian stencil).
#
# Why is that important for TPS/IRF-2?
# • TPS is only defined up to a plane; raw variances depend on where you pin that plane.
# • Using a plane-killing contrast gives **stationary increments**:
#   the contrast’s variance is (effectively) constant across locations and
#   its correlation depends mainly on distance.
#
# Make a weight vector that does: center − average(neighbors).
# This cancels any flat/tilted plane so it only measures curvature.
cardinalX<- rbind(c(0,0),
c(1,0),
c(0,1)
)
# Think of a thin-plate spline (TPS) surface like a flexible sheet with little bumps on it.
# You can lift the whole sheet up/down (change its level).
# You can tilt it like a tray (change its overall slope).
# Those moves don’t change the bumps. TPS only “cares” about the bumps.
# Because of that, the math can’t decide the sheet’s exact level/tilt unless we pin it down.
#
# This picks three pin locations. A plane (level + tilt) is determined by three points, so:
# 1st point fixes the height reference.
# 2nd point fixes tilt left–right.
# 3rd point fixes tilt up–down.
#
# Pick 3 anchor points to "pin" the plane (level & tilt),
# so TPS covariances are well-defined.
M<- 100
delta<- seq( 0,3,length.out=M)
#shift cross by delta, 100 different times of magnitude between 0-3
covTps<- rep( NA, M)
vars1<- rep( NA, M)
covTpsCenter<- rep( NA, M)
# create empty vectors of M size
tmp<- Tps.cov(s0,s0, cardinalX= cardinalX)
# Get the covariance between every pair of the 5 points in s0 (TPS model)
vars0 <- c(t(contrast)%*%tmp%*%contrast)
# Var of a weighted sum = weights × covariance table × weights.
for(k in 1:M ){
# Try the k-th distance between our two plus-shaped stamps.
s1<- s0 + delta[k]
# Make a second copy of the plus-shape and slide it diagonally by delta[k].
# (Every point moves by (delta[k], delta[k]).)
tmp<- Tps.cov(s0,s1, cardinalX= cardinalX)
# Ask the “blanket model” how the readings from HOME (s0) and MOVED (s1)
# tend to wiggle together (a 5x5 cross-covariance matrix).
covTpsCenter[k]<- tmp[1,1] # raw covariance of two center points
# Pick out the togetherness of the two CENTER dots:
# home center vs moved center.
covTps[k] <- t(contrast)%*%tmp%*%contrast
# Now measure togetherness of the “squish test” (center - average of arms)
# at home vs the same squish test at the moved cross.
tmp<- Tps.cov(s1,s1, cardinalX= cardinalX)
# Ask how the MOVED cross’s own readings wiggle with themselves
# (a 5x5 covariance/variance matrix for s1).
vars1[k] <- t(contrast)%*%tmp%*%contrast
# How wiggly the MOVED “squish test” is by itself — its variance.
}
plot( delta, # how far we slid the second cross
covTps/sqrt( vars0*vars1), #covariance between the two contrasts
# / the variance of that contrast at the original and shifted crosses
# sqrt turns covariance into a correlation
type="l",
xlab="distance separation", ylab="correlation contrasts")
# correlation of “curvature readings” vs how far apart the two crosses are.
# Interpretation: in the thin-plate-spline (TPS) model,
# the local curvature at one place tells you less and less about the curvature at another place as separation grows;
# after about that distance, they’re essentially unrelated.
stats( vars1) # variance is constant
# here is the plot for just correlation among the center points
S0<- rbind( c(0,0))
# home center dot at spot (0,0
S1<- matrix(s0, byrow=TRUE, nrow=M, ncol=2) +delta
# all the moved center dots
COV01<- Tps.cov(S0,S1, cardinalX= cardinalX)
# How much do the heights of the home center and each moved center wiggle together?
VAR0<- c(Tps.cov(S0,S0, cardinalX= cardinalX))
# How much does the home center wiggle by itself?
VAR1<-  diag( Tps.cov(S1,S1, cardinalX= cardinalX))
# And how much does each moved center wiggle by itself?
# funny variation due to interaction of delta spacing with
# cardinal points.
plot( delta, VAR1)
title("weird - not stationary")
plot( delta, COV01/ sqrt( VAR1*VAR0), type="l")
title( "correlations")
